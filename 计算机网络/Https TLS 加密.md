

## HTTPS是什么？SSL/TLS又是什么

由于Http天生明文的特点，在整个传输过程中是完全透明的，任何人都能够在链路中截获、修改或者伪造请求或者响应报文，所谓Http是不安全的，如果一个请求具备了**机密性、完整性、身份认证和不可否认**那么就可以认为是安全的。

**机密性**：是指对数据的保密，只能由可信的人访问，对其他人是不可见的秘密，简单来说就是不能让不相关的人看到不该看的东西。

**完整性**：是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。

**身份认证**：是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。

**不可否认**：也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。

Https是一个非常简单的协议，协议名是https，默认端口号是443，其它的都完全沿用Http，没有任何新的东西，https把http的下层传输协议由TCP/IP换成了SSL/TLS，让http运行在安全的SSL/TLS协议上，收发报文不在使用Socket API而是调用专门的安全接口。

<img src="https://cdn.jsdelivr.net/gh/ArrayTeng/resources/50d57e18813e18270747806d5d73f0a3.png" style="zoom:24%;" />



SSL是安全套接层（安全通信协议）在OSI模型中处于会话层，SSL和TLS是同一个东西的不同叫法，目前最广泛使用的是TLS1.2版本，TLS由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等众多密码学技术。浏览器和服务器在连接的时候需要选择一组恰当的加密算法来实现安全通信，这些算法被称为“密码套件”。TLS的米密码套件命名非常规范，格式固定，基本形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”



## 对称加密与非对称加密

按照密钥的使用方式加密可以分为对称加密和非对称加密，对称加密就是指加密和解密的密钥都是同一个，只要保证了密钥的安全那整个通信过程就是安全的，目前常用的对称加密算法有AES和ChaCha20。



非对称加密指的是公钥加密，私钥解密（公钥可以公开给任何人使用，私钥必须严格保密）但其中有个很大的问题：如何把密钥安全的传输给对方（密钥交换），公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。非对称加密算法常用是RSA。



虽然非对称加密解决了密钥交换的问题，但是运行速度很慢，如果仅仅只是使用了非对称加密那么虽然保证了安全但是通信速度很慢，解决办法也就是现在的TLS里使用的混合加密，在通信刚开始的时候使用非对称加密比如RSA首先解决密钥交换的问题，然后用随机数产生对称算法使用的“会话密钥”，在用公钥加密，对方拿到密文后用私钥解密取出会话密钥，这样就实现了对称密钥的交换，后序不在使用非对称加密，全部使用对称加密。**这样混合加密就解决了对称加密算法的密钥交换问题，而且安全和性能兼顾，完美地实现了机密性。**

## 数字签名

因为有可能存在伪造公钥的情况，所以在机密性的基础上还必须加上完整性、身份认证等特性才能实现真正的安全。实现数据完整性的手段主要是摘要算法，摘要算法是特殊的单向加密算法，只有算法没有密钥，不能从摘要逆推出原文，目前TLS推荐使用的摘要算法是SHA-2。通信双方使用摘要算法生成“数据摘要”，数据的获取方在拿到对方发送过来的数据时拿到对方的摘要以及数据报文，通过数据报文获生成摘要，对比对方传递过来的摘要来判断数据是否中途被修改过**进而实现校验数据的完整性**，不过摘要算法不具备机密性，如果明文传输那么在修改信息后把摘要也一起改了网站还是鉴别不出完整性。**所以完整性必须建立在机密性的基础之上。**



**使用私钥加上摘要算法就能够实现数字签名同时实现身份认证和不可否认**，使用私钥加密摘要生成数字签名，只有这个私钥对应的公钥才可以解开，拿到摘要后在校验数据的完整性就可以证明消息是你发的。



服务器去CA机构申请证书，证书中包含了要发给客户端的公钥、签发者、到期时间等等信息。如果这样简单地把证书发给浏览器，中间人可以轻松地修改成自己的公钥，之后的通信就是不安全的了。于是需要一定的加密手段，这里的做法就是使用数字签名：将证书的信息利用摘要算法计算出摘要之后，用CA的秘钥进行加密，生成数字签名。

服务器将数字证书和数字签名一起发给浏览器，因为有数字签名，所以数字证书无法被中间人做修改，浏览器拿到数字证书之后，去本地的信任机构中查询到对应的机构，利用其公钥解密数字签名，验证证书是否有被修改过。这一步就保证了浏览器获取到的公钥一定是正确的。

公钥正确地传给浏览器之后，接着就是协商对称加密的密钥，然后通信等等



↓ 对称加密（有密钥交换的问题）
↓ 非对称加密（基于复杂的数学难题，运行速度很慢）
↓ 混合加密（怎么保证完整性？不被修改？）
↓ 摘要算法（无法保证是用户自己）
↓ 数字签名（公钥怎么保证安全正确的？）
↓ 数字证书、CA

## TLS1.2连接过程

在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，在 TCP 上建立安全连接，之后才是收发 HTTP 报文。

![](https://cdn.jsdelivr.net/gh/ArrayTeng/resources/9caba6d4b527052bbe7168ed4013011e.png)

第一阶段：C/S两端共享Client Random、Server Random 和 Server Params信息
客户端--->服务器：
客户端的版本号、支持的密码套件，还有一个随机数（Client Random）

服务端--->客户端：
客户端的版本号、选择的客户端列表的密码套件如：TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、随机数随机数（Server Random）

服务端--->客户端：
服务端证书（Server Certificate）


服务端--->客户端：
发送Server Key Exchange类型的请求，携带椭圆曲线的公钥（Server Params）用以实现密钥交换算法，另附私钥签名


服务端--->客户端：
发送完毕


第二阶段：证书验证

前验条件：客户端证书链逐级验证、证书公钥验证签名，服务端身份验证成功（证书合法）

客户端--->服务端
发送Client Key Exchange类型的请求，携带椭圆曲线的公钥（Client Params）用以实现秘钥交换算法


第三阶段：主密钥生成

客户端、服务端分别使用Client Params、Server Params通过ECDHE算法计算出随机值pre-master，然后用
Client Random、Server Random 和 Pre-Master三个值作为原材料，用PRF伪随机数函数（利用密码套件的摘要算法再次强化结果
值maser secert的随机性）计算出主密钥Master Secret，

主密钥并不是会话秘钥，还会再用PRF扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）


客户端--->服务端:
客户端发一个“Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证.

服务端--->客户端：
服务器也是同样的操作，发“Change Cipher Spec”和“Finished”消息，双方都验证加密解密 OK，握手正式结束.



服务器将证书发送给浏览器

## 参考资料

[极客时间](https://time.geekbang.org/column/article/109062)

[数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)




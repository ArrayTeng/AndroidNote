[TOC]

# 线程的生命周期

![线程的生命周期](https://cdn.jsdelivr.net/gh/ArrayTeng/resources/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

## 新建线程的方式

首先在这里补充下基础知识，什么是并发与并行，并发指的是交替执行任务，并行指的是同时执行不同的任务，进程与线程的区别，进程是程序进行资源分配的最小单元，线程是CPU调度的单元，线程必须依赖进程而存在。

新建线程的方式有

1. 继承Thread类，然后执行run方法
2. 实现Runable，然后交给Thread执行
3. 实现Callable，然后交给Thread执行
4. 线程池的方式

第1、2方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果

## 阻塞线程的方式



## 如何正确的通知线程关闭

​		线程的自然终止要么是run执行完毕要么是执行过程中抛出了异常导致线程提前结束，在jdk中线程的暂停、恢复、停止操作对应着suspend()、resume()、stop()、但是这些函数已经被标记过时的，以suspend()函数举例子，当执行这个函数的时候线程不会释放已经持有的资源，比如说锁，而是会持有这个锁进入睡眠状态，在这种情况下就容易出现死锁，当线程执行stop()函数来关闭一个线程的时候不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。

​		安全的中止则是其他线程通过调用某个线程A的**interrupt()**方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，线程通过方法**isInterrupted()**来进行判断是否被中断，也可以调用静态方法**Thread.interrupted()**来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如sleep等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。

# 常见面试题



## 多线程为什么会有并发问题，为什么多个线程对同一个变量进行操作会有并发问题？

java内存模型规定了所有变量都存储在主内存中，每条线程由自己的工作内存

线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有的操作必须在工作内存中进行，而不能直接读写主内存

线程访问一个变量，首先将变量从主内存拷贝到工作内存中，对变量的操作不会马上同步到主内存

不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量传递需要自己的工作内存和主内存之间进行数据同步

## 并发编程的三要素

原子性：可以理解为在一个操作中，CPU不可以在中途暂停然后在调度，不可以被中断操作，要么执行完，要么就不执行。

可见性：多个线程访问同一个变量的时候，一个线程修改了这个变量的值，那么其它线程能够立即看到修改的值

有序性：程序的执行的顺序是按照代码的先后顺序执行



## 进程与线程的区别

进程是操作系统进行资源分配的最小单元，其中的资源包括CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程的全部系统资源，进程之间是相互独立的，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单元。进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。

线程是CPU调度的最小单元，必须依赖于进程而存在，线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。



## 并发与并行的区别

并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到"同时执行效果",其实并不是的,只是计算机的速度太快,我们无法察觉到而已.

并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行

两者区别:一个是交替执行,一个是同时执行.



## CPU密集型与IO密集型

1、CPU 密集型、计算密集型
 计算密集型，顾名思义就是应用需要非常多的CPU计算资源，在多核CPU时代，我们要让每一个CPU核心都参与计算，将CPU的性能充分利用起来，这样才算是没有浪费服务器配置，如果在非常好的服务器配置上还运行着单线程程序那将是多么重大的浪费。对于计算密集型的应用，完全是靠CPU的核数来工作，所以为了让它的优势完全发挥出来，避免过多的线程上下文切换，比较理想方案是：
线程数 = CPU核数+1
 也可以设置成CPU核数*2，这还是要看JDK的使用版本，以及CPU配置(服务器的CPU有超线程)。对于JDK1.8来说，里面增加了一个并行计算，计算密集型的较理想线程数 = CPU内核线程数*2

2、IO密集型
对于IO密集型的应用，就很好理解了，我们现在做的开发大部分都是WEB应用，涉及到大量的网络传输，不仅如此，与数据库，与缓存间的交互也涉及到IO，一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。因此从这里可以发现，对于IO密集型的应用，我们可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，线程可以去做其它事，提高并发处理效率。
 那么这个线程池的数据量是不是可以随便设置呢？当然不是的，请一定要记得，线程上下文切换是有代价的。目前总结了一套公式，对于IO密集型应用：
线程数 = CPU核心数/(1-阻塞系数)
 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。套用公式，对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整。



# 参考资料

1. [面试官：说说多线程并发问题](https://www.jianshu.com/p/da2dabfce94e)

2. [并发编程](https://www.codercc.com/backend/basic/juc/)

   


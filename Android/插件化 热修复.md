[TOC]

# 关于Dalvik、ART、DEX、JIT、AOT

**Android Runtime**（缩写为ART），是一种在[Android](https://zh.wikipedia.org/wiki/Android)操作系统上的[运行环境](https://zh.wikipedia.org/wiki/运行环境)，由[Google公司](https://zh.wikipedia.org/wiki/Google公司)研发，并在2013年作为[Android 4.4](https://zh.wikipedia.org/wiki/Android_4.4)系统中的一项测试功能正式对外发布，在[Android 5.0](https://zh.wikipedia.org/wiki/Android_5.0)及后续Android版本中作为正式的运行时库取代了以往的[Dalvik虚拟机](https://zh.wikipedia.org/wiki/Dalvik虚拟机)。ART能够把应用程序的[字节码](https://zh.wikipedia.org/wiki/字节码)转换为[机器码](https://zh.wikipedia.org/wiki/機器碼)，是Android所使用的一种新的[虚拟机](https://zh.wikipedia.org/wiki/虚拟机)。它与Dalvik的主要不同在于：Dalvik采用的是[JIT](https://zh.wikipedia.org/wiki/JIT)技术，而ART采用[Ahead-of-time](https://zh.wikipedia.org/w/index.php?title=Ahead-of-time_compilation&action=edit&redlink=1)（AOT）技术。ART同时也改善了性能、[垃圾回收](https://zh.wikipedia.org/wiki/垃圾回收_(計算機科學))（Garbage Collection）、应用程序出错以及性能分析。

JIT最早在[Android 2.2](https://zh.wikipedia.org/wiki/Android_2.2)系统中引进到Dalvik虚拟机中，在应用程序启动时，JIT通过进行连续的[性能分析](https://zh.wikipedia.org/wiki/性能分析)来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作。与Dalvik虚拟机不同的是，ART引入了AOT这种预编译技术，在应用程序安装的过程中，ART就已经将所有的字节码重新编译成了机器码。应用程序运行过程中无需进行实时的编译工作，只需要进行直接调用。因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升。为了保证[向下兼容](https://zh.wikipedia.org/wiki/向下兼容)，ART使用了相同的Dalvik字节码文件（dex），即在应用程序目录下保留了dex文件供旧程序调用，然而.odex文件则替换成了[可执行与可链接格式](https://zh.wikipedia.org/wiki/可執行與可鏈接格式)（ELF）可执行文件。一旦一个程序被ART的dex2oat命令[编译](https://zh.wikipedia.org/wiki/编译)，那么这个程序将会指通过ELF[可执行文件](https://zh.wikipedia.org/wiki/可执行文件)来运行。因此，相对于Dalvik虚拟机模式，ART模式下Android应用程序的安装需要消耗更多的时间，同时也会占用更大的内部储存空间，用于储存编译后的代码，但节省了很多Dalvik虚拟机用于实时编译的时间。

Google公司在Android 4.4中带来的ART模式仅仅是ART的一个预览版，系统默认仍然使用的是Dalvik虚拟机，4.4上面提供的预览版ART相对于Android 5.0以后的ART运行时库有较大的不同，尤其体现在兼容性上。

摘录自[维基百科 Android Runtime](https://zh.wikipedia.org/wiki/Android_Runtime)





# 双亲委托机制

## PathClassLoader 与 DexClassLoader

Android给我们提供了PathClassLoader和DexClassLoader用于加载dex文件，两者都继承自BaseDexClassLoader，就代码实现和用法上没有任何区别，抛在网上误导人的文章PathClassLoader和DexClassLoader都可以加载外部的 dex / apk 文件，只不过区别是DexClassLoader可以指定 optimizedDirectory，也就是dex2oat的产物 odex 存放的位置，而 PathClassLoader 只能使用系统默认位置。但是这个 optimizedDirectory 在 Android 8.0 以后也被舍弃了，只能使用系统默认的位置了。

## ClassLoader源码分析

某个类加载器在加载类时，如果将加载任务委托给父类加载器，一次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务或者没有父类加载器的时候才自己去加载。

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // 检查这个 Class 文件是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                  //如果没有被加载检查是否有父ClassLoader，将它委托给父ClassLoader
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    //如果父ClassLoader没有找到对应的类执行findClass函数自己去查找
                    c = findClass(name);
                }
            }
            return c;
    }
```



```java
//ClassLoader是一个抽象类， findClass由具体的实现类去处理
//BaseDexClassLoder.java
@Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // First, check whether the class is present in our shared libraries.
        if (sharedLibraryLoaders != null) {
            for (ClassLoader loader : sharedLibraryLoaders) {
                try {
                    return loader.loadClass(name);
                } catch (ClassNotFoundException ignored) {
                }
            }
        }
        
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
      //核心代码在 pathList.findClass , pathList是DexPathList 
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                    "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }
```

```java
//执行 DexPathList 的findClass函数 
public Class<?> findClass(String name, List<Throwable> suppressed) {
  //核心代码在 dexElements 数组，Element可以看作是dex文件的包装，Element的findClass函数最终会执行 DexFile的loadClassBinaryName 函数，最终的加载操作是交给一个本地函数 loadClassBinaryName 来执行的
        for (Element element : dexElements) {
          //每一个Element你就可以理解为是一个dex，通常情况下一个apk只有一个dex文件，所以你在执行热修复的操作的时候可以将问题代码打包成dex，确保将修复好的dex文件塞入到“问题dex”前面
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }

        if (dexElementsSuppressedExceptions != null) {
            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
        }
        return null;
    }
```


[TOC]

# 关于Dalvik、ART、DEX、JIT、AOT









# PathClassLoader 与 DexClassLoader



ClassLoader

BootClassLoader

用于加载Android Framework层class文件

PathClassLoader

用于Android应用程序类加载器，可以加载指定的dex，以及jar、zip、apk中的classes.dex

DexClassLoader

加载指定的dex，以及jar、zip、apk中的classes.dex



# 双亲委托机制

某个类加载器在加载类时，如果将加载任务委托给父类加载器，一次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务或者没有父类加载器的时候才自己去加载。

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // 检查这个 Class 文件是否已经被加载过了
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                  //如果没有被加载检查是否有父ClassLoader，将它委托给父ClassLoader
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    //如果父ClassLoader没有找到对应的类执行findClass函数自己去查找
                    c = findClass(name);
                }
            }
            return c;
    }
```



```java
//ClassLoader是一个抽象类， findClass由具体的实现类去处理
//BaseDexClassLoder.java
@Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // First, check whether the class is present in our shared libraries.
        if (sharedLibraryLoaders != null) {
            for (ClassLoader loader : sharedLibraryLoaders) {
                try {
                    return loader.loadClass(name);
                } catch (ClassNotFoundException ignored) {
                }
            }
        }
        
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
      //核心代码在 pathList.findClass , pathList是DexPathList 
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                    "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }
```

```java
//执行 DexPathList 的findClass函数 
public Class<?> findClass(String name, List<Throwable> suppressed) {
  //核心代码在 dexElements 数组，Element可以看作是dex文件的包装，Element的findClass函数最终会执行 DexFile的loadClassBinaryName 函数，最终的加载操作是交给一个本地函数 loadClassBinaryName 来执行的
        for (Element element : dexElements) {
          //每一个Element你就可以理解为是一个dex，通常情况下一个apk只有一个dex文件，所以你在执行热修复的操作的时候可以将问题代码打包成dex，确保将修复好的dex文件塞入到“问题dex”前面
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }

        if (dexElementsSuppressedExceptions != null) {
            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
        }
        return null;
    }
```


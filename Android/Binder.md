[TOC]

# 为什么Android提供Binder实现IPC

Android系统是基于Linux，Linux已经提供了管道、消息队列、共享内存和Socket等IPC机制，那为什么还要提供binder呢，主要是基于安全性、稳定性、性能这几方面考虑的。

## 性能

Socket作为一款通用接口，传输效率低，开销大，主要用在网络的进程间通信和本机上进程间的低速通信，消息队列和管道采用存储转发的方式来进行数据传递，数据先从发送方的缓存区拷贝到内核开辟的缓存区，然后在从内核缓存区拷贝到接收方缓存区，这期间至少经历了两次拷贝。共享内存虽然不需要拷贝但是控制复杂，Binder只需要一次数据拷贝，性能上仅次于共享内存。

![各种IPC方式数据拷贝次数](https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_720w.jpg)

## 稳定性

Binder基于C/S架构，客户端有什么需求直接丢给服务端去完成，职责明确架构清晰相互独立各司其职自然稳定性就好，共享内存虽然不需要拷贝但是控制复杂难操作，所以从稳定性的角度上来讲Binder更优。

## 安全性

传统的IPC没有任何安全措施完全依赖上层协议，传统的IPC接收方无法获取到对方可靠的进程ID和用户ID，所以没办法鉴别对方的身份，Android为每一个应用分配好了自己的UID，所以可以依靠UID来判断对方是否可靠，传统的IPC只能由客户在数据包中填写UID/PID，但是这样不可靠容易被恶意使用，可靠的身份标记只能由IPC机制在内核中添加，传统的IPC接入点是开发的，这个也容易让恶意程序找到缺口，同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。

![Binder的优势](https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_720w.jpg)

# Linux下传统的进程间通信原理

![](https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_720w.jpg)

## 进程隔离

在操作系统中进程与进程之间的内存是不共享的，两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。

## 进程空间划分：用户空间/内核空间

操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space），简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。

## 系统调用：用户态与内核态

如果用户空间需要访问内核空间需要借助系统访问，系统访问是用户空间访问内核空间的唯一方式，确保了所有资源的操作都在内核的控制下完成，避免了用户程序对系统资源的越权访问，当一个任务执行系统访问陷入内核代码执行时称进程处于内核态，当进程执行自己的代码的时候称这种情况处于用户态。

> ```text
> copy_from_user() //将数据从用户空间拷贝到内核空间
> copy_to_user() //将数据从内核空间拷贝到用户空间
> ```

## Linux 下的传统 IPC 通信原理

![Linux下传统的IPC通信原理](https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_720w.jpg)

消息发送方将数据保存在内存缓存区，通过系统调用进入内核态，内核程序在内核空间开辟一块内核缓存区，调用copy_from_user()将数据从内存缓存区拷贝到内核缓存区，接收方在自己的用户空间开辟一块自己的内存缓存区，内核程序调用copy_to_user()将数据从内核空间拷贝到用户空间。

这种传统的 IPC 通信方式有两个问题：

1. 性能低下，一次数据传递需要经历：内存缓存区 --> 内核缓存区 --> 内存缓存区，需要 2 次数据拷贝；
2. 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。

# Binder跨进程通信原理

## 动态内核可加载模块 &&内存映射

正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的**动态内核可加载模块**（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。

> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 **Binder 驱动**（Binder Dirver）。

那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。

这就不得不通道 Linux 下的另一个概念：**内存映射**。

Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。

内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。

## Binder IPC 实现原理

![](https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_720w.jpg)

1、首先Binder驱动在内核空间创建一个数据接收缓存区；

2、接着在内核空间开辟一个内核缓存区，建立内核缓存区与数据接收缓存之间的映射关系，以及数据接收缓存区与接收进程用户空间地址之间的映射关系；

3、发送方进程通过系统调用 copyfromUser 将数据copy到内核缓存区，由于内核缓存区与接收进程用户空间存在内存映射关系，也就等于是将数据发送到了接收进程的用户空间，这样就完成了一次进程间的通信。

# 相关题型
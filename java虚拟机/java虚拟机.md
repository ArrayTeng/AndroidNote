# Java内存区域

Java运行时数据区域可以划分为线程私有的虚拟机栈，程序计数器，本地方法栈，以及线程共享的堆和方法区。
![image](https://pic.downk.cc/item/5ff1a0ff3ffa7d37b3a431db.jpg)

**程序计数器**

程序计数器是一块占据了较小空间的内存区域，程序计数器其实就是字节码的行号指示器，行号指示器工作时就是通过改变计数器的值来选择下一条需要执行的字节码指令。

**虚拟机找**

虚拟机栈描述的是Java方法执行的内存模型，每个方法在被执行的时候虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息，每一个方法在被执行到执行完成的过程就对应着一个栈帧的入栈和出栈的过程。

**本地方法栈**


**堆**

**方法区**



# Java内存模型

# Java对象创建，内存布局，访问定位

当Java虚拟机遇到一个字节码new指令时将首先会去检查这个指令的参数是否能在常量池中定义到一个类的符号引用并且检查这个类的符号引用代表的类是否已经被加载过，如果没有被加载过那么将执行类的加载流程，在类加载检查通过后虚拟机将会给新生对象分配内存，对象所需大小在类加载完成后便可以完全确定，为对象分配空间的任务实际上等同于将一块确定大小的内存块从Java堆中划分出来，分配方式分为“指针碰撞”和“空闲列表”，而使用哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理的能**力决定，对象的创建在虚拟机中是非常频繁的行为，即使仅仅只是修改指针所指向的位置，在并发的情况下也不是线程安全的，解决这个问题有两个方案：**一个是采用CAS配上失败重试；另一种是本地线程分配缓冲（TLAB）**，紧接着就是初始化分配到的空间所有属性设置默认值、设置对象头以及执行init函数，用以下几个步骤总结下对象创建的流程：
1. 执行new字节码指令
2. 分配内存
3. 处理并发安全问题
4. 初始化分配到的空间（默认的赋值以及显示的赋值）
5. 设置对象头（运行时元数据、类型指针）
6. 执行init函数初始化

在HotSpot虚拟机中对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充，对象头部分包括两类信息，第一类用于存储对象自身的运行时元数据如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等，第二类是类型指针，指向它的类型元数据指针，通过这个指针来确定该对象是哪个类的实例。实例数据是对象真正存储的有效信息，即我们在代码里所定义的各种类型的字段内容。对齐填充仅仅占到占位符的作用。可以使用JOL工具查看对象的内存布局。

java程序通过栈上的reference数据（指向对象的引用）来操作堆上的具体对象，由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有规定这个引用应该通过什么方式去定位和访问堆中的对象，所以对象访问方式也是取决于虚拟机实现而定。目前主流的对象的访问定位有两种句柄访问和直接指针，如果使用了句柄访问的话，java堆中将可能划分出一块内存来作为句柄池，reference中存储的就是对象的的句柄地址，而句柄中包含了对象的实例数据与类型数据各自具体的地址信息，如果使用直接指针访问的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

# 垃圾收集器与内存分配策略

**内存分配与回收策略**

**如何判断一个对象已死**

在垃圾收集器在收集垃圾之前首先要判断这个对象是否已经死亡具备被回收的条件，判断一个对象是否需要被回收有两种方法，“引用计数”和“可达性分析”。

引用计数：在对象中添加一个计数器，每当有一个地方引用它的时候，计数器值就加一，当引用失效的时候计数器的值就减一，任何时刻计数器的值为零的时候表示这个对象就是不可被使用的，但是单纯的引用计数没法解决循环引用的问题。

可达性分析：目前主流的判断对象已死是通过可达性分析，通过一系列GC Root 节点作为起始点集，从这些节点根据引用关系开始向下搜索，搜索过的路基被称为引用链，如果某个对象到Gc Root间没有任何引用链相连，那么这个对象就可以表示为不可能在被使用的，可作为 GC Roots 的对象有虚拟机栈和本地方法栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象等。

**通过什么办法可以解决引用指针循环引用的问题？**

通过强弱引用来实现，也就是将对象的引用计数分为强引用计数和弱引用计数两种，其中，对象的生命周期只受强引用计数控制。比如在解决对象 A 和 B 相互引用时，把 A 看成父 B 看成子，对象 A 通过强引用计数来引用 B，B 通过弱引用计数来引用 A。在 A 不再使用时，由于 B 是通过弱引用来引用它的，因此 A 的生命周期是不受 B 影响的，所以 A 可以安全的释放，在释放 A 时，同时也会释放它对 B 的强引用，这时 B 也可以被安全的回收了。

**Java中的引用关系**

强引用：类似 new Object() 这种引用关系，在任何情况下只要强引用关系还存在垃圾收集器就永远都不会收集被引用的对象

软引用：用来描述一些还有用但是非必须的对象，只被软引用关联着的对象在系统即将发生内存溢出异常的时候会把这些对象列入回收范围之内进行二次回收，如果这次回收还没有足够的内存那么才会抛出内存溢出异常。

弱引用：同样用来描述那些非必需的对象，但是强度比软引用要低一些，被弱引用关联的对象只能存活到下一次垃圾回收的时候，当垃圾收集器开始工作的时候无论当前的内存是否足够都会被回收掉。

虚引用：它是最弱的一种引用关系。一个对象是否有虚引用的
存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。


**垃圾收集算法**

# Java虚拟机类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析、初始化，最终形成可以被虚拟机直接使用的Java对象，这就是虚拟机的类加载机制。


虚拟机的类加载流程可以分为加载、连接、初始化这三步，其中连接阶段又可以被细分为验证、准备、解析。

**类加载的时机**

Java虚拟机没有强制约束在什么情况下可以执行加载的阶段，所以这一阶段可以留给虚拟机自己实现，但虚拟机明确规定了在以下几种情况下会执行初始化的过程，遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化，当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

**加载**

Java虚拟机在加载阶段**通过一个类的全限定名获取这个定义此类的二进制字节流**，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象，作为方法区的这个类的各种数据的访问入口。加载阶段是开发人员可控性最强的一个阶段，可以使用自定义的类加载器或者使用虚拟机内置的引导类加载器，而对于数组而言，数组类本身不是由类加载器加载构建的而是Java虚拟机直接在内存中创建的。

**验证**

在验证阶段主要就是为了确保Class文件字节流中的数据符合Java虚拟机的规范，主要包括文件格式验证，元数据验证，字节码验证和符号引用验证。

**准备**

准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都会在方法区中进行分配，不过这里分配的仅仅只是类变量的内存，实例变量将会在对象实例化的时候被分配在Java堆上，在准备阶段为类变量设置初始值的操作只是将变量设为该数据类型的零值，而真正赋值的动作要等到类的初始化阶段执行。

**解析**

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，直接引用可以是直接指向目标的指针。

**初始化**

初始化阶段是执行类构造器 <clinit>() 方法的过程，<clinit>() 方法是编译器自动收集类中为类变量赋值动作以及静态代码块中的语句合并而成的，编译器收集的顺序是语句在代码中出现的顺序决定的，<clinit>() 对于类或接口来说不是必须的，如果类中没有静态语句块那么虚拟机可以不生成 <clinit>() 函数，Java虚拟机会保证一个类中的 <clinit>() 函数在多线程的情况下会给正确的加锁，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，当前线程退出 <clinit>() 函数后，其它线程被唤醒也不会进入 <clinit>() ，在同一个类加载器下一个类型只会被初始化一次。这也是静态内部类能实现单例的原理。

**双亲委派模型**

![image](https://pic.downk.cc/item/5fe99ca23ffa7d37b3d30e51.png)

当一个类加载器收到加载请求的时候，它首先会把这个加载请求委托给父加载器来处理，如果这个父加载器没法处理这个请求，那么会继续委托给给父加载器直至启动类加载器，如果父加载器加载失败，子加载器才会尝试去加载。我们在理解类加载器的时候可以从三层类加载器结构来理解，从上到下依次为启动类加载器，扩展类加载器，应用程序类加载器以及自定义类加载器，每一层加载器都有它们加载的范围，启动类加载器只会加载 JAVA_HOME\lib 目录下的文件，并且是名字能够被是别的，名字不符合的类库就算放到lib目录下也不会被加载，扩展类加载器也差不多不过它负责加载ext目录下的文件，应用程序类加载器负责加载用户目录上的所有类库，一般情况下默认的加载器就是它。  
      
使用双亲委派模型最显而易见的好处就是Java的类随着类加载器具备了一种优先级的层次关系，比如说Object类，无论哪一个类加载器去加载它最终都会被启动类加载器处理，这就确保了在各种类加载环境下都能确保Object类的唯一以及避免了重复加载

# Java虚拟机器是如何实现方法调用的

Java虚拟机如何实现方法调用其实就是Java虚拟机如何识别目标方法的，重载的方法在编译阶段就可以确定下来了，具体到每一个方法的调用，Java编译器会根据所传入参数的类型来选取重载方法，方法重写需要在运行期间确定，Java虚拟机识别方法的关键在于类名，方法名以及方法描述符，方法描述符由方法的参数类型以及返回类型构成，在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。Java虚拟机中静态绑定指的的是在解析阶段就能够识别目标方法的情况，而动态绑定则是需要在动态运行时才能够确定目标方法，Java字节码中共有5种指令与调用相关：
- invokestatic：用于调用静态方法。
- invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
- invokevirtual：用于调用非私有实例方法。
- invokeinterface：用于调用接口方法。
- invokedynamic：用于调用动态方法。

对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法，而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。
如果Java虚拟机能确定的目标方法只有一个，比如方法被final修饰，那么就可以不通过动态类型直接确定方法。

# Java虚拟机是如何实现Synchronized

# Java虚拟机是如何实现反射的

# Java虚拟机是如何实现泛型的

# Java虚拟机是如何实现异常的
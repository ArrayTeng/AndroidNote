#### Java运行时数据区域
Java运行时数据区域可以分为线程私有的程序计数器、虚拟机栈、本地方法栈以及线程共享的堆、方法区，程序计数器占据了一块较小的内存空间，它可以看作是当前线程字节码的行号指示器，字节码解释器的工作就是依靠行号指示器来选取下一条需要执行的字节码指令，循环、跳转、异常处理以及线程恢复都是依靠这个计数器才能完成的，java虚拟机的多线程是通过线程轮流切换来执行的，在每一个时刻都只会执行一个线程中的指令，所以说为了每一个线程在切换后能恢复到之前的指令就需要每一个线程拥有一个独立的程序计数器,同程序计数器一样Java虚拟机栈也是线程私有的，Java虚拟机栈描述的是Java方法执行的线程内存模型，每一个Java方法在被执行的时候都会在Java虚拟机栈中同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息，Java方法被调用的过程就对应着栈帧的入栈和出栈的过程,在Java虚拟机栈中如果线程所请求的栈深度大于虚拟机所允许的深度那么就会抛出StackOverflowError异常，如果Java虚拟机栈容量可以动态扩展那么当栈扩展时没有申请到足够的内存那么就会抛出OutOfMemoryError异常，本地方法栈与Java虚拟机栈发挥的作用是相似的，不过本地方法栈描述的是Native方法执行的内存模型。

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存堆存在的唯一目的是存放对象实例，Java堆是垃圾收集器管理的内存区域，所以也可以被称之为GC堆，从内存回收的角度来看由于现代垃圾收集器大部分都是基于分代收集设计理论设计的，所以Java堆也可以被细分为新生代和老年代，在细致一点还可以把新生代分配为Eden区、From Survivor区和 To Survivor区，从内存分配的角度来看线程共享的Java堆还可以划分为多个线程私有的分配缓冲区，但是无论如何划分都不会改变Java堆中存储内容的共性，无论哪个区域存储的都只能是对象的实例，将Java堆细分的目的是为了更好的回收内存。

方法区和Java堆一样是线程共享的内存区域，它用于存储已经被java虚拟机加载的类型信息、常量、静态变量以及即时编译器编译后的代码缓存数据，JVM对方法区还是比较宽松的，除了和Java堆一样不需要连续的内存空间和可以选择固定大小或者可以扩展外，甚至可以选择不需要实现垃圾收集，相对而言垃圾收集在这个区域是比较少出现的。运行时常量池是方法区的一部分用于存储编译期生成的各种字面量与符号引用，运行时常量池相对比Class文件常量池一个重要的特点是具备动态性，运行期间可以将新的常量放入池中，比比如说String的intern()函数。




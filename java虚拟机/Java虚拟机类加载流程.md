
#### Java内存区域


#### Java虚拟机类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析、初始化，最终形成可以被虚拟机直接使用的Java对象，这就是虚拟机的类加载机制。


虚拟机的类加载流程可以分为加载、连接、初始化这三步，其中连接阶段又可以被细分为验证、准备、解析。

**类加载的时机**

Java虚拟机没有强制约束在什么情况下可以执行加载的阶段，所以这一阶段可以留给虚拟机自己把我，但虚拟机明确规定了在以下几种情况下会执行初始化的过程，遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段，使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化，当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。




**加载**

Java虚拟机在加载阶段通过一个类的全限定名获取这个定义此类的二进制字节流，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象，作为方法区的这个类的各种数据的访问入口。加载阶段是开发人员可控性最强的一个阶段，可以使用自定义的类加载器或者使用虚拟机内置的引导类加载器，而对于数组而言，数组类本身不是由类加载器加载构建的而是Java虚拟机直接在内存中创建的。

**验证**

在验证阶段主要就是为了确保Class文件字节流中的数据符合Java虚拟机的规范，主要包括文件格式验证，元数据验证，字节码验证和符号引用验证。

**准备**

准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都会在方法区中进行分配，不过这里分配的仅仅只是类变量的内存，实例变量将会在对象实例化的时候被分配在Java堆上，在准备阶段为类变量设置初始值的操作只是将变量设为该数据类型的零值，而真正赋值的动作要等到类的初始化阶段执行。

**解析**

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，直接引用可以是直接指向目标的指针。

**初始化**

初始化阶段是执行类构造器 clinit 方法的过程，clinit 方法是编译器自动收集类中为类变量赋值动作以及静态代码块中的语句合并而成的，编译器收集的顺序是语句在代码中出现的顺序决定的，clinit 对于类或接口来说不是必须的，如果类中没有静态语句块那么虚拟机可以不生成 clinit 函数，Java虚拟机会保证一个类中的 clinit 函数在多线程的情况下会给正确的加锁，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，当前线程退出 clinit 函数后，其它线程被唤醒也不会进入 clinit ，在同一个类加载器下一个类型只会被初始化一次。这也是静态内部类能实现单例的原理。

**双亲委派模型**

当一个类加载器收到加载请求的时候，它首先会把这个加载请求委托给父加载器来处理，如果这个父加载器没法处理这个请求，那么


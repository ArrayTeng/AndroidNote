#### JVM的类加载机制
虚拟机把描述类的Class文件加载到内存并对数据经过校验、解析、初始化的过程，最终形成可以被JVM直接使用的java对象，这就是JVM的类加载机制，类加载流程可以分为5个阶段分别为“加载”、“验证”、“解析”和初始化。

加载是指查找字节流并且据此创建类的过程，对于数组类而言它没有对应的字节流它是由JVM直接生成的，对于其它类而言，java虚拟机则需要借助类加载器来完成加载过程，在加载阶段就是通过一个类的全限定名来获取此类的二进制流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

验证是连接阶段的第一步,这一步的目的是为了验证Class字节流包含的信息符合JVM的规范,并且不会危害JVM的安全,验证阶段包含文件格式检验、元数据检验、字节码校验等。

准备阶段就是正式为类变量分配内存并且设置初始值的阶段,类变量会在方法区中分配内存,需要注意的是这里的分配内存仅仅只是为类变量分配内存而不是为实例变量设置内存,实例变量会在初始化的过程中跟对象一起在堆中分配内存,这里的设置初始值指的为类变量设置零值。

解析阶段就是虚拟机将常量池中的符号引用替换为直接引用的过程,符号引用就是以一组符号来描述所引用的目标,直接引用可以是直接指向目标的指针。

初始化阶段就是执行类构造器 <clinit>() 的过程，这个方法是Javac编译器自动收集类中的所有类变量的赋值操作动作和静态代码块中的语句合并而来的，构造器方法中的指令按语句在源码文件中出现的顺序执行，如果这个类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕，虚拟机保证了一个类的<clinit>()方法在多线程下被同步加锁

#### JAVA双亲委托机制 

如果一个类加载器收到了类加载流程,它并不会自己去加载,而是把这个请求委托给它的父类加载器去执行,如果父类加载器还存在其父类加载器那么进一步向上委托依次递归,请求最终将到达顶层的启动类加载器.如果父类加载器可以完成加载任务就成功返回,否则就将这个任务交子类去完成,这就是双亲委托机制。使用双亲委托可以避免类的重复加载防止核心API被随意篡改

#### 类的主动使用和被动使用
java程序对类的使用分为主动使用和被动使用,主动使用分为七种情况:1、创建类的实例,2、访问某个类或接口的静态变量,或者对该静态变量赋值,3、调用类的静态方法，4、反射，5、初始化一个类的子类，6、java虚拟机启动时被标明为启动类的类，7、jdk 7 开始提供的动态语言支持，除了以上七种情况，其它使用java类的方法都被看做是对类的被动使用都不会导致类的初始化
